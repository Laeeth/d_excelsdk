//// 
//// Autogenerated by xlw 
//// Do not edit this file, it will be overwritten 
//// by InterfaceGenerator 
////

#include "xlw/MyContainers.h"
#include <xlw/CellMatrix.h>
#include "DLL.h"
#include <xlw/xlw.h>
#include <xlw/XlFunctionRegistration.h>
#include <stdexcept>
#include <xlw/XlOpenClose.h>
#include <xlw/HiResTimer.h>
#include <xlw/ArgList.h>

using namespace xlw;

namespace {
const char* LibraryName = "Example";
};


// registrations start here


namespace
{
  XLRegistration::XLFunctionRegistrationHelper
registerEmptyArgFunction("xlEmptyArgFunction",
"EmptyArgFunction",
" tests empty args ",
LibraryName,
0,
0
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEmptyArgFunction(
)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

std::wstring result(
	EmptyArgFunction());
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoShortArgs[]=
{
{ "x"," number to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoShort("xlEchoShort",
"EchoShort",
" echoes a short ",
LibraryName,
EchoShortArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoShort(
LPXLFOPER xa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper xb(
	(xa));
short x(
	xb.AsShort("x"));

short result(
	EchoShort(
		x)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoMatArgs[]=
{
{ "Echoee"," argument to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoMat("xlEchoMat",
"EchoMat",
" echoes a matrix ",
LibraryName,
EchoMatArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoMat(
LPXLFOPER Echoeea)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper Echoeeb(
	(Echoeea));
MyMatrix Echoee(
	Echoeeb.AsMatrix("Echoee"));

MyMatrix result(
	EchoMat(
		Echoee)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoArrayArgs[]=
{
{ "Echoee","  argument to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoArray("xlEchoArray",
"EchoArray",
" echoes an array ",
LibraryName,
EchoArrayArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoArray(
LPXLFOPER Echoeea)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper Echoeeb(
	(Echoeea));
MyArray Echoee(
	Echoeeb.AsArray("Echoee"));

MyArray result(
	EchoArray(
		Echoee)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoCellsArgs[]=
{
{ "Echoee","  argument to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoCells("xlEchoCells",
"EchoCells",
" echoes a  CellMatrix ",
LibraryName,
EchoCellsArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoCells(
LPXLFOPER Echoeea)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper Echoeeb(
	(Echoeea));
CellMatrix Echoee(
	Echoeeb.AsCellMatrix("Echoee"));

 HiResTimer t;
CellMatrix result(
	EchoCells(
		Echoee)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
CircArgs[]=
{
{ "Diameter"," the circle's diameter ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerCirc("xlCirc",
"Circ",
" computes the circumference of a circle ",
LibraryName,
CircArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlCirc(
double Diameter)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);


double result(
	Circ(
		Diameter)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
ConcatArgs[]=
{
{ "str1"," first string ","XLF_OPER"},
{ "str2"," second string ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerConcat("xlConcat",
"Concat",
" Concatenates two strings ",
LibraryName,
ConcatArgs,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlConcat(
LPXLFOPER str1a,
LPXLFOPER str2a)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper str1b(
	(str1a));
std::wstring str1(
	str1b.AsWstring("str1"));

XlfOper str2b(
	(str2a));
std::wstring str2(
	str2b.AsWstring("str2"));

std::wstring result(
	Concat(
		str1,
		str2)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
statsArgs[]=
{
{ "data"," input for computation ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerstats("xlstats",
"stats",
" computes mean and variance of a range ",
LibraryName,
statsArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlstats(
LPXLFOPER dataa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper datab(
	(dataa));
MyArray data(
	datab.AsArray("data"));

 HiResTimer t;
MyArray result(
	stats(
		data)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
HelloWorldAgainArgs[]=
{
{ "name"," name to be echoed ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerHelloWorldAgain("xlHelloWorldAgain",
"HelloWorldAgain",
" says hello name ",
LibraryName,
HelloWorldAgainArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlHelloWorldAgain(
LPXLFOPER namea)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper nameb(
	(namea));
std::wstring name(
	nameb.AsWstring("name"));

std::wstring result(
	HelloWorldAgain(
		name)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoULArgs[]=
{
{ "b"," number to echo ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoUL("xlEchoUL",
"EchoUL",
" echoes an unsigned integer ",
LibraryName,
EchoULArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoUL(
double ba)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

unsigned long b(
	static_cast<unsigned long>(ba));

unsigned long result(
	EchoUL(
		b)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoIntArgs[]=
{
{ "b"," number to echo ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoInt("xlEchoInt",
"EchoInt",
" Echoes an integer ",
LibraryName,
EchoIntArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoInt(
double ba)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

int b(
	static_cast<int>(ba));

int result(
	EchoInt(
		b)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoDoubleOrNothingArgs[]=
{
{ "x"," value to specify ","XLF_OPER"},
{ "defaultValue"," default value ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoDoubleOrNothing("xlEchoDoubleOrNothing",
"EchoDoubleOrNothing",
" tests DoubleOrNothingType ",
LibraryName,
EchoDoubleOrNothingArgs,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoDoubleOrNothing(
LPXLFOPER xa,
double defaultValue)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper xb(
	(xa));
CellMatrix x(
	xb.AsCellMatrix("x"));


double result(
	EchoDoubleOrNothing(
		x,
		defaultValue)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
SystemTimeArgs[]=
{
{ "ticksPerSecond"," number to divide by ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerSystemTime("xlSystemTime",
"SystemTime",
" system clock ",
LibraryName,
SystemTimeArgs,
1
,true
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlSystemTime(
LPXLFOPER ticksPerSeconda)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper ticksPerSecondb(
	(ticksPerSeconda));
CellMatrix ticksPerSecond(
	ticksPerSecondb.AsCellMatrix("ticksPerSecond"));

 HiResTimer t;
double result(
	SystemTime(
		ticksPerSecond)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
EchoArgListArgs[]=
{
{ "args","  arguments to echo ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerEchoArgList("xlEchoArgList",
"EchoArgList",
" echoes arg list ",
LibraryName,
EchoArgListArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlEchoArgList(
LPXLFOPER argsa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper argsb(
	(argsa));
CellMatrix argsc(
	argsb.AsCellMatrix("argsc"));
ArgumentList args(
	ArgumentList(argsc,"args"));

 HiResTimer t;
CellMatrix result(
	EchoArgList(
		args)
	);
CellMatrix resultCells(result);
CellMatrix time(1,2);
time(0,0) = "time taken";
time(0,1) = t.elapsed();
resultCells.PushBottom(time);
return XlfOper(resultCells);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
PayOffEvaluationArgs[]=
{
{ "OptionPayoff","  table for payoff ","XLF_OPER"},
{ "Spot","  point for evaluation ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerPayOffEvaluation("xlPayOffEvaluation",
"PayOffEvaluation",
" evaluate pay--off ",
LibraryName,
PayOffEvaluationArgs,
2
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlPayOffEvaluation(
LPXLFOPER OptionPayoffa,
double Spot)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper OptionPayoffb(
	(OptionPayoffa));
CellMatrix OptionPayoff(
	OptionPayoffb.AsCellMatrix("OptionPayoff"));


double result(
	PayOffEvaluation(
		OptionPayoff,
		Spot)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
ContainsErrorArgs[]=
{
{ "input"," data to check for errors ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerContainsError("xlContainsError",
"ContainsError",
" checks to see if there's an error ",
LibraryName,
ContainsErrorArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlContainsError(
LPXLFOPER inputa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper inputb(
	(inputa));
CellMatrix input(
	inputb.AsCellMatrix("input"));

bool result(
	ContainsError(
		input)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
ContainsDivByZeroArgs[]=
{
{ "input"," data to check for errors ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerContainsDivByZero("xlContainsDivByZero",
"ContainsDivByZero",
" checks to see if there's a div by zero ",
LibraryName,
ContainsDivByZeroArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlContainsDivByZero(
LPXLFOPER inputa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper inputb(
	(inputa));
CellMatrix input(
	inputb.AsCellMatrix("input"));

bool result(
	ContainsDivByZero(
		input)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
  XLRegistration::XLFunctionRegistrationHelper
registerGetThreadId("xlGetThreadId",
"GetThreadId",
" Gets the thread id ",
LibraryName,
0,
0
,true
,true
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlGetThreadId(
)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

double result(
	GetThreadId());
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
typeStringArgs[]=
{
{ "input"," parameter ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registertypeString("xltypeString",
"typeString",
" return a string indicating datatype of OPER/OPER12 input ",
LibraryName,
typeStringArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xltypeString(
LPXLFOPER inputa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper inputb(
	(inputa));
CellMatrix input(
	inputb.AsCellMatrix("input"));

std::wstring result(
	typeString(
		input)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
typeString2Args[]=
{
{ "input"," parameter ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registertypeString2("xltypeString2",
"typeString2",
" return a string indicating datatype of XLOPER/XLOPER12 input ",
LibraryName,
typeString2Args,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xltypeString2(
LPXLFOPER inputa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper inputb(
	(inputa));
CellMatrix input(
	inputb.AsCellMatrix("input"));

std::wstring result(
	typeString2(
		input)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
CastToCSArrayArgs[]=
{
{ "csarray","  double Array ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerCastToCSArray("xlCastToCSArray",
"CastToCSArray",
" takes double[] ",
LibraryName,
CastToCSArrayArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlCastToCSArray(
LPXLFOPER csarraya)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper csarrayb(
	(csarraya));
MyArray csarray(
	csarrayb.AsArray("csarray"));

MyArray result(
	CastToCSArray(
		csarray)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
CastToCSArrayTwiceArgs[]=
{
{ "csarray","  double Array ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerCastToCSArrayTwice("xlCastToCSArrayTwice",
"CastToCSArrayTwice",
" takes double[] ",
LibraryName,
CastToCSArrayTwiceArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlCastToCSArrayTwice(
LPXLFOPER csarraya)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper csarrayb(
	(csarraya));
MyArray csarray(
	csarrayb.AsArray("csarray"));

MyArray result(
	CastToCSArrayTwice(
		csarray)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
CastToCSMatrixArgs[]=
{
{ "csmatrix","  double Array ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerCastToCSMatrix("xlCastToCSMatrix",
"CastToCSMatrix",
" takes double[,] ",
LibraryName,
CastToCSMatrixArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlCastToCSMatrix(
LPXLFOPER csmatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper csmatrixb(
	(csmatrixa));
MyMatrix csmatrix(
	csmatrixb.AsMatrix("csmatrix"));

MyMatrix result(
	CastToCSMatrix(
		csmatrix)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
CastToCSMatrixTwiceArgs[]=
{
{ "csmatrix","  double Array ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerCastToCSMatrixTwice("xlCastToCSMatrixTwice",
"CastToCSMatrixTwice",
" takes double[,] ",
LibraryName,
CastToCSMatrixTwiceArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlCastToCSMatrixTwice(
LPXLFOPER csmatrixa)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper csmatrixb(
	(csmatrixa));
MyMatrix csmatrix(
	csmatrixb.AsMatrix("csmatrix"));

MyMatrix result(
	CastToCSMatrixTwice(
		csmatrix)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
throwStringArgs[]=
{
{ "err"," Just any random string ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerthrowString("xlthrowString",
"throwString",
" throws an exception of type ArgumentNullException ",
LibraryName,
throwStringArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlthrowString(
LPXLFOPER erra)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper errb(
	(erra));
std::wstring err(
	errb.AsWstring("err"));

double result(
	throwString(
		err)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
throwCellMatrixArgs[]=
{
{ "err"," Just any random string ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerthrowCellMatrix("xlthrowCellMatrix",
"throwCellMatrix",
" throws an exception of type cellMatrixException ",
LibraryName,
throwCellMatrixArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlthrowCellMatrix(
LPXLFOPER erra)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper errb(
	(erra));
std::wstring err(
	errb.AsWstring("err"));

double result(
	throwCellMatrix(
		err)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
throwCErrorArgs[]=
{
{ "err"," Just any random string ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerthrowCError("xlthrowCError",
"throwCError",
" makes the C Runtime throw an exception ",
LibraryName,
throwCErrorArgs,
1
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlthrowCError(
LPXLFOPER erra)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper errb(
	(erra));
std::wstring err(
	errb.AsWstring("err"));

double result(
	throwCError(
		err)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
GetHistoricDataFromYahooArgs[]=
{
{ "symbol"," Yahoo Symbol ","XLF_OPER"},
{ "beginDate"," Begin Date ","B"},
{ "endDate"," End Date ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registerGetHistoricDataFromYahoo("xlGetHistoricDataFromYahoo",
"GetHistoricDataFromYahoo",
" Obtains historial market data from yahoo ",
LibraryName,
GetHistoricDataFromYahooArgs,
3
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlGetHistoricDataFromYahoo(
LPXLFOPER symbola,
double beginDate,
double endDate)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);

XlfOper symbolb(
	(symbola));
std::wstring symbol(
	symbolb.AsWstring("symbol"));



CellMatrix result(
	GetHistoricDataFromYahoo(
		symbol,
		beginDate,
		endDate)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoOpen
//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoClose
//////////////////////////

